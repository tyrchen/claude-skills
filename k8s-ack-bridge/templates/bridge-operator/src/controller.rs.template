//! {{RESOURCE_KIND}} controller reconciliation logic.
//!
//! This module implements reconciliation for `{{RESOURCE_KIND}}` resources.
//! Replace {{RESOURCE_KIND}}, {{GROUP}}, {{VERSION}} with your resource details.
//!
//! # Status Update Pattern (CRITICAL)
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────────┐
//! │ RULE: Only update status in TWO cases:                         │
//! │   1. When RETURNING EARLY (waiting for something)              │
//! │   2. At the VERY END (final ready/error status)                │
//! │                                                                 │
//! │ NEVER update status then continue to next phase.               │
//! │ This causes reconciliation loops and status flapping.          │
//! └─────────────────────────────────────────────────────────────────┘
//! ```
//!
//! Each status update triggers a new reconciliation via the watcher.
//! See bridge-patterns.md "Critical: Status Update Rules" for details.

use std::sync::Arc;
use std::time::Duration;

use futures::StreamExt;
use k8s_openapi::apimachinery::pkg::apis::meta::v1::OwnerReference;
use kube::ResourceExt;
use kube::api::{Api, DeleteParams, Patch, PatchParams, PostParams};
use kube::core::DynamicObject;
use kube::runtime::controller::{Action, Controller};
use kube::runtime::finalizer::{Event, finalizer};
use kube::runtime::watcher::Config;
use serde_json::json;
use tracing::{debug, error, info, instrument, warn};

use super::{Error, State};
use crate::crd::{{{RESOURCE_KIND}}, {{RESOURCE_KIND}}Status, Condition};

// ============================================================================
// Constants
// ============================================================================

/// Finalizer name for cleanup operations.
const FINALIZER_NAME: &str = "{{GROUP}}/{{RESOURCE_KIND_LOWER}}";

/// ACK deletion policy annotation key.
const ACK_DELETION_POLICY_KEY: &str = "services.k8s.aws/deletion-policy";

/// ACK deletion policy value - retain AWS resources on K8s deletion.
const ACK_DELETION_POLICY_VALUE: &str = "retain";

/// Requeue durations
const REQUEUE_AFTER_CREATING: Duration = Duration::from_secs(15);
const REQUEUE_AFTER_ERROR: Duration = Duration::from_secs(60);
const REQUEUE_AFTER_SUCCESS: Duration = Duration::from_secs(300);

// ============================================================================
// Controller Entry Point
// ============================================================================

/// Runs the {{RESOURCE_KIND}} controller.
pub async fn run(state: Arc<State>) -> anyhow::Result<()> {
    let api = Api::<{{RESOURCE_KIND}}>::all(state.client.clone());
    let config = Config::default().any_semantic();

    info!("starting {{RESOURCE_KIND}} controller");

    Controller::new(api, config)
        .shutdown_on_signal()
        .run(reconcile, error_policy, state)
        .for_each(|result| async {
            match result {
                Ok((obj, _action)) => {
                    info!(name = %obj.name, "reconciled successfully");
                }
                Err(e) => {
                    error!(error = %e, "reconciliation failed");
                }
            }
        })
        .await;

    info!("{{RESOURCE_KIND}} controller shutdown");
    Ok(())
}

// ============================================================================
// Reconciliation Logic
// ============================================================================

/// Main reconciliation function.
#[instrument(skip(ctx), fields(
    name = %resource.name_any(),
    namespace = resource.namespace().unwrap_or_default(),
    generation = resource.metadata.generation.unwrap_or(0)
))]
async fn reconcile(resource: Arc<{{RESOURCE_KIND}}>, ctx: Arc<State>) -> Result<Action, Error> {
    let ns = resource.namespace().ok_or(Error::MissingField("namespace"))?;

    info!("reconciling {{RESOURCE_KIND}}");

    let api: Api<{{RESOURCE_KIND}}> = Api::namespaced(ctx.client.clone(), &ns);

    // Use finalizer for proper cleanup
    let action = finalizer(&api, FINALIZER_NAME, resource, |event| async {
        match event {
            Event::Apply(r) => reconcile_apply(r, &ctx, &ns).await,
            Event::Cleanup(r) => reconcile_cleanup(r, &ctx, &ns).await,
        }
    })
    .await
    .map_err(|e| Error::Finalizer(e.to_string()))?;

    info!(?action, "reconciliation completed");
    Ok(action)
}

/// Apply/create logic for the reconciler.
async fn reconcile_apply(
    resource: Arc<{{RESOURCE_KIND}}>,
    ctx: &State,
    ns: &str,
) -> Result<Action, Error> {
    let name = resource.name_any();
    let api: Api<{{RESOURCE_KIND}}> = Api::namespaced(ctx.client.clone(), ns);
    let generation = resource.metadata.generation.unwrap_or(0);

    info!(name = %name, "starting reconciliation");

    // Phase 1: Check prerequisites
    // TODO: Implement prerequisite checks
    // if !prereqs_ready {
    //     update_status(&api, &name, StatusUpdate::waiting_for_prereqs(generation)).await?;
    //     return Ok(Action::requeue(REQUEUE_AFTER_CREATING));
    // }

    // Phase 2: Create primary resources
    // TODO: Implement primary resource creation
    // create_primary_resource(&resource, ctx, ns).await?;
    // if !is_primary_ready(ctx, ns, &name).await? {
    //     update_status(&api, &name, StatusUpdate::primary_creating(generation)).await?;
    //     return Ok(Action::requeue(REQUEUE_AFTER_CREATING));
    // }

    // Phase 3: Create secondary resources
    // TODO: Implement secondary resource creation

    // Phase 4: Direct AWS operations (UPSERT semantics)
    // TODO: Implement direct AWS operations
    // ctx.aws_client.upsert_resource(...).await?;

    // Final: Update status to ready
    update_status(
        &api,
        &name,
        StatusUpdate::ready(generation),
    )
    .await?;

    info!("reconciliation complete - resource is ready");
    Ok(Action::requeue(REQUEUE_AFTER_SUCCESS))
}

/// Cleanup logic on deletion.
async fn reconcile_cleanup(
    resource: Arc<{{RESOURCE_KIND}}>,
    ctx: &State,
    ns: &str,
) -> Result<Action, Error> {
    let name = resource.name_any();

    info!(name = %name, "cleaning up {{RESOURCE_KIND}}");

    // Delete in reverse order of creation

    // 1. Delete direct AWS resources first (idempotent)
    // TODO: Implement direct AWS deletion
    // if let Err(e) = ctx.aws_client.delete_resource(...).await {
    //     warn!(error = %e, "failed to delete AWS resource (continuing)");
    // }

    // 2. Delete ACK resources (best effort, uses retain policy)
    // TODO: Delete ACK resources
    // delete_ack_resource(ctx, ns, "service.services.k8s.aws", "ResourceKind", &name).await;

    info!(name = %name, "cleanup complete");
    Ok(Action::await_change())
}

/// Error policy for requeueing after errors.
#[allow(clippy::needless_pass_by_value)]
fn error_policy(resource: Arc<{{RESOURCE_KIND}}>, error: &Error, _ctx: Arc<State>) -> Action {
    let ns = resource.namespace().unwrap_or_default();
    warn!(
        name = %resource.name_any(),
        namespace = %ns,
        error = %error,
        "reconciliation error, requeueing"
    );
    Action::requeue(REQUEUE_AFTER_ERROR)
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Creates an `ApiResource` for ACK CRDs.
fn ack_api_resource(group: &str, kind: &str) -> kube::discovery::ApiResource {
    let plural = pluralize(kind);
    kube::discovery::ApiResource {
        group: group.to_string(),
        version: "v1alpha1".to_string(),
        kind: kind.to_string(),
        api_version: format!("{group}/v1alpha1"),
        plural,
    }
}

/// Pluralizes a kind name for API resource.
fn pluralize(kind: &str) -> String {
    let lower = kind.to_lowercase();
    if lower.ends_with('s') {
        format!("{lower}es")
    } else if lower.ends_with('y') {
        format!("{}ies", &lower[..lower.len() - 1])
    } else {
        format!("{lower}s")
    }
}

/// Creates standard annotations for ACK resources.
fn ack_resource_annotations() -> std::collections::BTreeMap<String, String> {
    [(
        ACK_DELETION_POLICY_KEY.to_string(),
        ACK_DELETION_POLICY_VALUE.to_string(),
    )]
    .into_iter()
    .collect()
}

/// Creates standard labels for ACK resources.
fn ack_resource_labels() -> std::collections::BTreeMap<String, String> {
    [("app.kubernetes.io/created-by".to_string(), "{{OPERATOR_NAME}}".to_string())]
        .into_iter()
        .collect()
}

/// Creates an owner reference pointing to the parent resource.
fn owner_reference(resource: &{{RESOURCE_KIND}}) -> OwnerReference {
    OwnerReference {
        api_version: "{{GROUP}}/{{VERSION}}".to_string(),
        kind: "{{RESOURCE_KIND}}".to_string(),
        name: resource.name_any(),
        uid: resource.metadata.uid.clone().unwrap_or_default(),
        controller: Some(true),
        block_owner_deletion: Some(true),
    }
}

/// Deletes an ACK resource (best effort).
async fn delete_ack_resource(ctx: &State, ns: &str, group: &str, kind: &str, name: &str) {
    let api_resource = ack_api_resource(group, kind);
    let api: Api<DynamicObject> = Api::namespaced_with(ctx.client.clone(), ns, &api_resource);

    match api.delete(name, &DeleteParams::default()).await {
        Ok(_) => {
            info!(kind = %kind, name = %name, "deleted ACK resource");
        }
        Err(kube::Error::Api(e)) if e.code == 404 => {
            debug!(kind = %kind, name = %name, "ACK resource already gone");
        }
        Err(e) => {
            warn!(kind = %kind, name = %name, error = %e, "failed to delete ACK resource");
        }
    }
}

/// Checks if an ACK resource is synced.
pub fn is_ack_resource_synced(obj: &DynamicObject) -> bool {
    obj.data
        .get("status")
        .and_then(|s| s.get("conditions"))
        .and_then(|c| c.as_array())
        .map(|conditions| {
            conditions.iter().any(|c| {
                c.get("type").and_then(|t| t.as_str()) == Some("ACK.ResourceSynced")
                    && c.get("status").and_then(|s| s.as_str()) == Some("True")
            })
        })
        .unwrap_or(false)
}

// ============================================================================
// Status Update Helpers
// ============================================================================

struct StatusUpdate {
    ready: bool,
    conditions: Vec<Condition>,
    observed_generation: i64,
    // Add resource-specific status fields here
}

impl StatusUpdate {
    fn waiting_for_prereqs(generation: i64) -> Self {
        Self {
            ready: false,
            conditions: vec![
                Condition::new(
                    "Ready",
                    "False",
                    "WaitingForPrerequisites",
                    "Waiting for prerequisites",
                    generation,
                ),
            ],
            observed_generation: generation,
        }
    }

    fn ready(generation: i64) -> Self {
        Self {
            ready: true,
            conditions: vec![
                Condition::new(
                    "Ready",
                    "True",
                    "Ready",
                    "All resources ready",
                    generation,
                ),
            ],
            observed_generation: generation,
        }
    }
}

async fn update_status(
    api: &Api<{{RESOURCE_KIND}}>,
    name: &str,
    update: StatusUpdate,
) -> Result<(), Error> {
    let status = {{RESOURCE_KIND}}Status {
        ready: update.ready,
        conditions: update.conditions,
        observed_generation: update.observed_generation,
        // Add resource-specific status fields here
    };

    let patch = json!({ "status": status });
    api.patch_status(name, &PatchParams::default(), &Patch::Merge(&patch))
        .await?;

    Ok(())
}
